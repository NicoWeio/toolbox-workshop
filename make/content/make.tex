\begin{frame}{Automatisierte, reproduzierbare Prozesse}

  {\huge Problem:}
  \vspace{1em}
  \begin{itemize}
    \item kurz vor Abgabe noch neue Korrekturen einpflegen
      \begin{itemize}
        \item Tippfehler korrigieren, Plots bearbeiten
      \end{itemize}
    \item \TeX{} ausführen, ausdrucken
    \item vergessen, Plots neu zu erstellen
  \end{itemize}
\end{frame}

\begin{frame}{Automatisierte, reproduzierbare Prozesse}

  {\huge Lösung: Make!}
  \vspace{1em}
  \begin{itemize}
    \item sieht, welche Dateien geändert wurden
    \item berechnet nötige Operationen
    \item führt Python-Skript aus, führt \TeX{} aus
  \end{itemize}
\end{frame}

\begin{frame}{Motivation}
  \begin{itemize}
    \item Automatisierung verhindert Fehler
    \item Dient als Dokumentation
    \item Reproduzierbarkeit unverzichtbar in der Wissenschaft
    \item Idealfall: Eingabe von \texttt{make} erstellt komplettes Protokoll/Paper aus Daten
    \item Spart Zeit, da nur nötige Operationen ausgeführt werden
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Makefile}
  \begin{itemize}
    \item Datei heißt \texttt{Makefile}, keine Endung!
      \begin{itemize}
        \item bei Windows Dateiendungen einschalten! (\url{http://support.microsoft.com/kb/865219/de})
      \end{itemize}
    \item besteht aus Rules:
  \end{itemize}
  \begin{block}{Rule}
    \begin{lstmake}
      target: prerequisites
          recipe
    \end{lstmake}
  \end{block}
  \begin{description}
    \item[\texttt{\hphantom{prerequisites}\llap{target}}] Datei(en), die von dieser Rule erzeugt werden
    \item[\texttt{prerequisites}]                         Dateien, von denen diese Rule abhängt
    \item[\texttt{\hphantom{prerequisites}\llap{recipe}}] Befehle: \texttt{prerequisites} → \texttt{target} (mit Tab eingerückt)
  \end{description}
\end{frame}

\begin{frame}[fragile]{Einfachstes Beispiel}
  \begin{lstmake}
    plot.pdf: plot.py data.txt
        python plot.py
  \end{lstmake}
\end{frame}

\begin{frame}[fragile]{Beispiel}
  \begin{lstmake}
    all: report.pdf  # convention

    plot.pdf: plot.py data.txt
        python plot.py

    report.pdf: report.tex
        lualatex report.tex

    report.pdf: plot.pdf  # add prerequisite
  \end{lstmake}
  \vspace{1em}

  \texttt{make} eingeben:
  \begin{itemize}
    \item \texttt{all} braucht \texttt{report.pdf}
      \begin{itemize}
        \item \texttt{report.pdf} braucht \texttt{plot.pdf}
          \begin{itemize}
            \item \texttt{python plot.py}
          \end{itemize}
        \item \texttt{lualatex report.tex}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Funktionsweise}
  \begin{center}
    \begin{tikzpicture}
      \graph [
        grow down,
        branch right sep,
        nodes={
          node font=\ttfamily,
        },
      ] {
        "all" [x=3.5] -> "report.pdf" [x=3] -> {
          "report.tex",
          "plot.pdf" -> {
            "plot.py", "data.txt"
          },
          "plot2.pdf" -> {
            "plot2.py", "data.txt", "data2.txt"
          },
        },
      };
    \end{tikzpicture}
  \end{center}

  \begin{itemize}
    \item Abhängigkeiten bilden einen DAG (directed acyclic graph)
    \item Dateien werden neu erstellt, falls sie nicht existieren oder älter als ihre Prerequisites sind
    \item Prerequisites werden zuerst erstellt
    \item top-down Vorgehen
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Argumente für \texttt{make}}
  \begin{tabu}{>{\ttfamily}l X[,L]}
    make \textit{target} & statt des ersten in der \texttt{Makefile} genannten Targets (meist \texttt{all}) nur \texttt{target} erstellen \\
    make -n              & dry run: Befehle anzeigen aber nicht ausführen \\
    make -d              & debug: anzeigen, warum \texttt{make} sich so entschieden hat \\
    make -p              & Datenbank aller Abhängigkeiten ausgeben
  \end{tabu}
  \begin{itemize}
    \item Nützlich, wenn man einen Plot bearbeitet: \texttt{make plot.pdf}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{\texttt{make clean}}
  Es ist eine (nützliche) Konvention, dass \texttt{make clean} alles vom \texttt{Makefile} erstellte löscht.

  \vspace{1em}
  \begin{lstmake}
    clean:
        rm plot.pdf report.pdf
  \end{lstmake}
  \vspace{1em}

  Das Projekt sollte dann so aussehen wie vor dem ersten Ausführen von \texttt{make}.
\end{frame}

\begin{frame}[fragile]{Advanced}
  \texttt{build}-Ordner: Projekt sauber halten

  \vspace{0.9em}
  \begin{lstmake}
    all: build/report.tex

    build/plot.pdf: plot.py data.txt | build
        python plot.py  # savefig('build/plot.pdf')

    build/report.pdf: report.tex build/plot.pdf | build
        lualatex --output-directory=build report.tex

    build:
        mkdir -p build

    clean:
        rm -rf build

    .PHONY: all clean
  \end{lstmake}
  \vspace{0.9em}

  \begin{itemize}
    \item \texttt{| build} ist ein order-only Prerequisite: Alter wird ignoriert
    \item Targets, die bei \texttt{.PHONY} genannt werden, entsprechen nicht Dateien (guter Stil)
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Expert}
  Mehrere unabhängige Auswertungen: könnte man sie parallel ausführen? \\
  Ja! \texttt{make -j4} (4 Prozesse gleichzeitig)

  \vspace{1em}
  \begin{lstmake}
    plot1.pdf plot2.pdf: plot.py data.txt
        python plot.py
  \end{lstmake}
  \vspace{1em}

  Problem: \texttt{make} führt \texttt{plot.py} gleichzeitig zweimal aus

  Lösung: manuell synchronisieren

  \vspace{1em}
  \begin{lstmake}
    plot1.pdf: plot.py data.txt
        python plot.py

    plot2.pdf: plot1.pdf
  \end{lstmake}
  \vspace{1em}

  Wenn man \texttt{plot2.pdf} aber nicht \texttt{plot1.pdf} löscht, kann \texttt{make} nicht mehr \texttt{plot2.pdf} erstellen.
\end{frame}
