\newcommand{\mail}{\includegraphics[width=0.2\textwidth]{figures/mail.pdf}}
\tikzstyle{arr}=[line width=1mm,draw=black,-triangle 45]
\tabulinesep=4pt

\headlineframe{Wie arbeitet man am besten an einem Protokoll zusammen?}

\headlineframe{Idee: Austausch über Mails}

\begin{frame}{Mails: Probleme}
  \centering
  \begin{tikzpicture}
    \node (alice) at (0, 0) {\includegraphics[width=0.2\textwidth]{figures/text.pdf}};
    \node (bob) at (8, 0) {\includegraphics[width=0.2\textwidth]{figures/text.pdf}};
    \draw[arr] (alice) -- node {\mail} (bob);
  \end{tikzpicture}
  \begin{itemize}
    \item Risiko, dass Änderungen vergessen werden, ist groß
    \item Bei jedem Abgleich muss jemand anders aktiv werden
      \begin{itemize}
        \item Stört
        \item Es kommt zu Verzögerungen
      \end{itemize}
  \end{itemize}
  \textbf{\Large Fazit: Eine sehr unbequeme / riskante Lösung}
\end{frame}

\headlineframe{Idee: Austausch über Dropbox}

\begin{frame}{Dropbox: Probleme}
  \centering
  \begin{tikzpicture}
    \node (alice) at (0, 0) {\includegraphics[width=0.2\textwidth]{figures/text.pdf}};
    \node[align=center,fill=blue!20,rounded corners=1em] (dropbox) at (4, 0.5) {
      \includegraphics[width=0.1\textwidth]{logos/dropbox.pdf}\\
      \includegraphics[width=0.2\textwidth]{figures/text.pdf}
    };
    \node (bob) at (8, 0) {\includegraphics[width=0.2\textwidth]{figures/text.pdf}};
    \draw[arr,triangle 45-triangle 45] (0.8, 0) -- (dropbox);
    \draw[arr,triangle 45-triangle 45] (dropbox) -- (7.2, 0);
  \end{tikzpicture}

  \begin{itemize}
    \item Man merkt nichts von Änderungen der Anderen
    \item Gleichzeitige Änderungen führen zu \enquote{In Konflikt stehende Kopie}-Dateien.
    \item Änderungen werden nicht zusammengeführt.
  \end{itemize}
  \textbf{\Large Fazit: Besser, aber hat deutliche Probleme}
\end{frame}

\headlineframe{Lösung: Änderungen verwalten mit \texttt{git}}

\begin{frame}
    \centering
    \includegraphics[width=0.7\textwidth]{logos/git.pdf}

    \vspace{1em}

    \begin{itemize}
      \item Ein Versionskontrollsystem
      \item Ursprünglich entwickelt, um den Programmcode des Linux-Kernels zu verwalten (Linus Torvalds)
      \item Hat sich gegenüber ähnlichen Programmen (SVN, mercurial) durchgesetzt
    \end{itemize}
\end{frame}

\begin{frame}{Was bringt \texttt{git} für Vorteile?}
  \begin{itemize}
    \item Arbeit wird für andere sichtbar protokolliert
    \item Erlaubt Zurückspringen an einen früheren Zeitpunkt
    \item Kann die meisten Änderungen automatisch zusammenfügen
    \item Wirkt nebenbei auch als Backup
  \end{itemize}
  Einziges Problem: Man muss lernen, damit umzugehen
\end{frame}

\begin{frame}{Zentrales Konzept: Das Repository}
  \begin{itemize}
    \item Erzeugen mit \texttt{git init}
  \end{itemize}
  \vspace{3em}
  \centering
  \begin{tikzpicture}[line width=1.5]
    \node (wd) at (0, 0) [draw,rounded corners,thick,minimum width=4cm,minimum height=1.2cm,fill=red!20] {Working directory};
    \node (idx) [below=0.4cm of wd,draw,thick,rounded corners,minimum width=4cm,minimum height=1.2cm,fill=yellow!20] {Staging};
    \node (hist) [below=0.4cm of idx,draw,rounded corners,thick,minimum width=4cm,minimum height=1.2cm,fill=green!20] {History};
    \draw[thick,->] (wd.east) to[out=0,in=0] node[right] {\texttt{git add}} (idx.east);
    \draw[thick,->] (idx.west) to[out=180,in=180] node[left] {\texttt{git commit}} (hist.west);
  \end{tikzpicture}
\end{frame}

\begin{frame}{History}
  \begin{tikzpicture}
    \graph [nodes=blue] {
      "v1.2" [green, x=4],
      a <- b <- c <- d <- {e <- f, g [x=0.5]} <- h <- {i <- master [red], j <- foo [red]};
      "v1.2" -> e;
    };
  \end{tikzpicture}

  \vspace{1em}
  \begin{itemize}
    \item \textcolor{blue}{Commit}: Zustand/Inhalt des Arbeitsverzeichnisses zu einem Zeitpunkt
      \begin{itemize}
        \item Snapshot, Name ist Hash des Inhalts, enthält Commit-Message (Beschreibung der Änderungen)
      \end{itemize}
    \item \textcolor{red}{Branch}: benannter Zeiger auf einen Commit
      \begin{itemize}
        \item Entwicklungszweig, im Praktikum nur \texttt{master}
      \end{itemize}
    \item \textcolor{green}{Tag}: unveränderbarer Zeiger auf einen Commit
      \begin{itemize}
        \item Wichtiges Ereignis, z.B. veröffentlichte Version
      \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Workflow}
  \begin{enumerate}
    \item Repo erzeugen/klonen: \texttt{git init}, \texttt{git clone}
    \item Arbeiten
      \begin{enumerate}
        \item Dateien bearbeiten, testen: \texttt{vim}, \texttt{make}
        \item Änderungen in Staging schieben: \texttt{git add}
        \item Commit erzeugen: \texttt{git commit}
      \end{enumerate}
    \item Commits anderer herunterladen und integrieren: \texttt{git pull}
    \item Eigene Commits hochladen: \texttt{git push}
  \end{enumerate}
\end{frame}

\begin{frame}{\texttt{git init}, \texttt{git clone}}
  \begin{tabu}{>{\ttfamily}l X}
    git init               & initialisiert ein \texttt{git}-Repo im jetzigen Verzeichnis \\
    git clone \textit{url} & klont das Repo aus \texttt{\textit{url}} \\
    rm -rf .git            & löscht alle Spuren von \texttt{git} aus dem Repo
  \end{tabu}
\end{frame}

\begin{frame}{\texttt{git status}, \texttt{git log}}
  \begin{tabu}{>{\ttfamily}l X}
    git status & zeigt Status des Repos (welche Dateien sind neu, gelöscht, verschoben, bearbeitet) \\
    git log    & listet Commits in aktuellem Branch
  \end{tabu}
\end{frame}

\begin{frame}{\texttt{git add}, \texttt{git mv}, \texttt{git rm}, \texttt{git reset}}
  \begin{tabu}{>{\ttfamily}l X}
    git add \textit{file} … & fügt Dateien/Verzeichnisse zum Staging-Bereich hinzu \\
    git add -p …            & fügt Teile einer Datei zum Staging-Bereich hinzu \\
    git mv                  & wie \texttt{mv} (automatisch in Staging)\\
    git rm                  & wie \texttt{rm} (automatisch in Staging) \\
    git reset \textit{file} & entfernt Dateien/Verzeichnisse aus Staging
  \end{tabu}
\end{frame}

\begin{frame}{\texttt{git diff}}
  \begin{tabu}{>{\ttfamily}l X}
    git diff                                   & zeigt Unterschiede zwischen Staging und Arbeitsverzeichnis \\
    git diff --staged                          & zeigt Unterschiede zwischen letzten Commit und Staging \\
    git diff \textit{commit1} \textit{commit2} & zeigt Unterschiede zwischen zwei Commits
  \end{tabu}
\end{frame}

\begin{frame}{\texttt{git commit}}
  \begin{tabu}{>{\ttfamily}l X}
    git commit                       & erzeugt Commit aus jetzigem Staging-Bereich, öffnet Editor für Commit-Message \\
    git commit -m "\textit{message}" & Commit mit \texttt{\textit{message}} als Message \\
    git commit --amend               & letzten Commit ändern (fügt aktuellen Staging hinzu, Message bearbeitbar)
  \end{tabu}

  \begin{itemize}
    \item Sinnvolle Commit-Messages schreiben!
      \begin{itemize}
        \item Erster Satz ist Zusammenfassung
      \end{itemize}
    \item Logische Commits erstellen, für jede logische Einheit ein Commit
      \begin{itemize}
        \item \texttt{git add -p} sehr nützlich
      \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{\texttt{git pull}, \texttt{git push}}
  \begin{tabu}{>{\ttfamily}l X}
    git pull          & Commits herunterladen (mit Merge-Commit) \\
    git pull --rebase & Commits herunterladen (ohne Merge-Commit) \\
    git push          & Commits hochladen
  \end{tabu}

  \begin{itemize}
    \item (falls gewollt) \texttt{--rebase} standardmäßig: \\
      \texttt{git config --global pull.rebase true}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Achtung: Merge conflicts}
  \begin{center}
    \huge Don't Panic
  \end{center}

  Entstehen, wenn \texttt{git} nicht automatisch mergen kann (selbe Zeile geändert, etc.)

  \begin{enumerate}
    \item Die betroffenen Dateien öffnen
    \item Markierungen finden und die Stelle selbst mergen (meist wenige Zeilen)
      \begin{verbatim}
        <<<<<<< HEAD
        foo
        ||||||| merged common ancestors
        bar
        =======
        baz
        >>>>>>> Commit-Message
\end{verbatim}
    \item Merge abschließen: \texttt{git add …}
      \begin{itemize}
        \item kein \texttt{--rebase}: \texttt{git commit} ausführen, um zu bestätigen
        \item \texttt{--rebase}: \texttt{git rebase --continue}
      \end{itemize}
  \end{enumerate}
  Nützlich: \texttt{git config --global merge.conflictstyle diff3}
\end{frame}

\begin{frame}{\texttt{git checkout}}
  \begin{tabu}{>{\ttfamily}l X}
    git checkout \textit{commit} & Commit ins Arbeitsverzeichnis laden \\
    git checkout \textit{file}   & Änderungen an Dateien verwerfen (zum letzten Commit zurückkehren)
  \end{tabu}
\end{frame}

\begin{frame}{\texttt{git stash}}
  \begin{tabu}{>{\ttfamily}l X}
    git stash     & Änderungen kurz zur Seite schieben \\
    git stash pop & Änderungen zurückholen aus Stash
  \end{tabu}
\end{frame}

\begin{frame}
    \frametitle{\texttt{.gitignore}}
    \begin{itemize}
    \item Man möchte nicht alle Dateien von \texttt{git} beobachten lassen
    \item z.B. \texttt{build/}--Ordner
    \end{itemize}
    \begin{center}
        \Large\textcolor{TUgreen}{Lösung:} \texttt{.gitignore}--Datei
    \end{center}
\end{frame}

\begin{frame}[fragile]
    \frametitle{\texttt{.gitignore}}
    \begin{itemize}
    \item einfache Textdatei
    \item enthält Regeln für Dateien, die nicht beobachtet werden sollen
    \end{itemize}
    Beispiel:
    \begin{lstlisting}
    build/
    *.pdf
    __pycache__
    \end{lstlisting}
\end{frame}


